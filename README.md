**本开发周期的总体目标是在T-Designer中深度集成T-Solver的系统建模、功能管理与D矩阵相关功能。**具体包括：参照T-Solver中的器件建模，将元件属性中的"元件T语言"迁移至smt-lib体系，smt描述中的端口名与元件属性中"功能子块"的端号要对齐，根据元件间的连线关系自动生成T-Solver中的系统中元件端口连接关系描述，参照T-Solver中的功能管理，重构本软件当前的"系统功能管理"相关界面与业务代码，移植T-Solver中的D矩阵生成功能、D矩阵查看的相关界面与业务代码。在本软件中深度集成T-Solver现有的系统建模、功能管理与D矩阵生成与查看功能，并与当前软件已有的基于D矩阵的业务流程无缝衔接，如设定约束条件下的测试优选、测试性指标预计、诊断决策树生成等。
﹣需要花大量的时间分析总体目标，并详细、深入地规划设计总体解决方案，并做任务分解，列出分解后的任务清单，逐项完成；将复杂的任务分解为多个相对简单的可核查的子任务有助于整体任务的解决，这部分不要怕浪费时间，正所谓磨刀不误砍柴工。
﹣不要急着出结果，全部已有代码及文档都需要仔细阅读并深度理解，所有细节你慢慢做，不要节约token，一次做对做好最重要。 

实现要点：

1. 需要仔细阅读并深刻理解下文"T-Solver模型说明"中的建模原理、方法以及具体实现细节；
2. 当前软件中的功能子块只是CAD的绘图单位，一个元件中可能有多个功能子块，但都应用smt-lib语法在元件的"元件T语言"中统一描述；且smt描述中的端口与变量需要与元件的端口设置对齐。比如一个继电器KA，器件代号为KA1，有功能子块Coil（线圈）与Contact（触点），功能子块Coil有2个端口A1、A2，端号为"A1|A2"(同一个功能子块的多个端号用"|"分隔)，功能子块Contact有3个端口"11|14|12"，上述都是电气端口，所以体现在元件的smt描述中就是10个变量：KA1.Coil.A1.i、KA1.Coil.A1.u、KA1.Coil.A2.i、KA1.Coil.A2.u、KA1.Contact.11.i、KA1.Contact.11.u、KA1.Contact.14.i、KA1.Contact.14.u、KA1.Contact.12.i、KA1.Contact.12.u。有3种类型的端口：电气/液压/机械，电气，液压对应的端口变量分别为i（电流）、u（电压），p（压力）、q（流量）；机械对应的端口变量分别为F（力）、v（速度）/n（转速）/x（位移），后面3个根据元件的具体功能和应用选一个合适的即可。对于电器/液压/机械元件，常见的内部参数有R(电阻)/r(液阻)/Z(阻尼)。对于端口之间的物理连接，可以仿照T-Solver中使用连接函数connect2e、connect3e、connect2h、connect3h、connect2m、connect3m，（分别对应电气/液压/机械的2/3端口相连）将从CAD图纸中获取的连接语义转换为smt模型中元件之间的端口连接，其原理是通过smt语句描述元件端口变量间的约束关系（如基尔霍夫定律），具体实现上，可使用connect2e等连接函数（本质上是一种语法糖）来建立这些约束。
3. T-Designer有两个类似的界面："本地物料库"（窗口标题为“数据库管理”，通过主界面导航栏中的"数据管理"->"本地物料库"进入）以及"元件属性"（窗口标题为"元件属性"，在项目导航器的"元件"tab页中的实体元件的右键菜单中选择"元件属性"进入）；"本地物料库"相当于模板库，提供对模板库中元件的编辑、修改功能（对应LdMainData.db），"元件属性"相当于从模板库中实例化后的元件的编辑、修改界面，数据存在项目数据库（项目文件夹下与项目同名的db文件）中。无论是对"本地物料库"中的元件模板或者对项目数据库中的实例化元件进行编辑、修改，内容都是大同小异的，在设计功能以及编写代码时要尽量复用代码，避免相同的逻辑要分别在两处地方分别维护。
4. 需要实现一个"元件T语言"的校验功能，同时能在"本地物料库"以及"元件属性"的"T语言模型"/"元件T语言"中提供一致的校验功能，且复用代码，校验内容有：1）是否符合smt-lib语法，即检查是否有syntax错误；2）元器件的smt描述是否和元件的端口设置一致。
5. 需要在本软件的"元件属性"以及"本地物料库"中的"功能子块"tab中"端口配置"tab页中对端口的类型（电气/液压/机械/其他）进行设置，可选择默认的端口变量（i、u、p、q、F、v、n、x等），也可自定义，用户可自己创建自定义端口变量及相应的connect连接函数；软件上需要考虑周全，并为用户提供相应的界面，并实现其业务逻辑。
6. 对元件、系统的smt描述以及对系统功能的描述需要存储在项目数据库（项目文件夹下与项目同名的db文件）中，不要再另设数据库文件。如果需要更新项目据库的结构、设计时：① 在工程目录`./MyProjects`中的项目同名 `db`文件上进行验证；② 评审通过后更新 `templete/project.db`（因为新建项目时就时直接拷贝一个project.db模板数据库到`./MyProjects`下的项目同名目录中并重命名，所以源头上的数据库是这个文件）；③ 可直接使用sqlite3命令查看、编辑sqlite数据库的db文件，或编写python脚本来构建/更新工程数据库文件，如采用python脚本，则将其存储在`./tools`目录），鉴于本项目尚未交付，在数据库结构、软件结构更新时，应优先保证新设计的简洁可靠与合理性，暂不需过多考虑对旧版本的兼容性。
7. 参照T-Solver中的功能管理，重构本软件当前的"系统功能管理"相关界面与业务代码，在功能管理页面，链路（link）信息可根据T-Designer项目中的连线信息自动构建"链路信息"，用户可以进一步修改、确认。
8. T-Designer中"测试管理"窗口中的"依赖矩阵"tab页需要完整参照T-Solver中的dmatrixviewerdialog界面与显示、操作逻辑以及实现细节进行重构。D矩阵的数据结构与储存方式参照T-Solver的实现并在其基础上进一步扩充（补充测试的多维度信息如：测试复杂性、测试费用、测试时间、测试描述、检测成功率、备注信息等，补充故障的多维度信息如：故障概率、故障影响严重度、备注信息等）。
9. 现在T-Designer中已实现分层容器模型，层次包括：系统、子系统、LRU、SRU、模块、子模块、元件；**元件级容器作为实体元件的封装和代理，其接口与行为模型应直接继承自所包含的单一实体元件。本阶段的开发应基于此原则，将新增的SMT建模、功能管理等逻辑主要实现在容器层面，尽可能减少对现有实体元件内部代码的侵入。**现有软件可为插入到图纸中的实体"元件"建立元件级容器，然后系统可以再建立不同层次的容器，现有软件中的实体"元件"不能同时隶属于多个同层级容器，某一低层级容器也不能同时隶属于多个同层级的高层容器，用户可通过软件界面方便地对实体元件进行层次化的管理。比如一个实体“元件”继电器K1，被插入到系统中，默认会自动为其生成一个同名元件层的容器，这个元件层由于有且只有K1，所以这个元件层容器可以直接根据继电器K1现有的接口描述（功能子块）、功能行为描述（元件T语言）来生成自己的接口描述与功能行为描述。本开发周期的主要工作主要聚焦于元件级容器，在元件级容器上进行测试性建模、分析，避免对当前软件中实体元件的底层实现进行过多改动，而容器是新加入的内容，修改起来没有历史包袱。不同级别容器间的等效替代与模型描述的自动整合留到以后再做，本开发周期中只有元件的层次化管理、以及系统测试性指标的多层级分解（对高层级容器指定一组测试性指标，使用一定算法将总的指标分解到各低层级的容器上去）、测试性指标分层级统计（在元件级容器层面进行测试性指标预计，然后可以按层级进行汇总统计与显示）。

# T-Solver模型说明

描述语言采用SMTLIB2规范（Satisfiability Modulo Theories Library 2.0，是SMT求解器领域的标准输入输出格式规范，可采用现有的一些成熟求解器进行求解，如本项目使用的微软Z3求解器）。

目前所设计的诊断的框架方法为： 对于每个器件，定义1个正常模式，n个已知故障模式，1个未知故障模式（n≥0），且每个故障模式均定义一个先验的发生概率。每个模式下代数表达式（等式或不等式）描述其相关变量须满足的约束关系。 诊断的过程就是将被诊断功能相关的器件、外部输入、观测对应的变量描述语句放到一起，器件端口之间的连接采用共享变量的方式实现，进行求解看有没有解。其中器件的定义语句是根据器件推定的模式（正常模式/故障模式）来选择的，然后对所有器件的可能模式进行组合（实际工程项目中，不需要列出所有组合，列出概率相对较大的即可），如果在某个器件模式组合下，约束求解器输出结果为有解，则表示当前的这组对器件状态的推定可以解释所观测到的现象。 这样就可以利用约束求解器求解由代数表达式描述的器件约束关系的方式来对系统进行诊断。 诊断框架使用了约束满足性（constraint satisfaction）的方法，使用不同的模式来表示每个器件的不同状态，然后将这些状态的约束与观测结果相结合，用约束求解器（如Z3）来找出能满足所有约束的器件状态。

## 器件模型要素

- 字段结构（数据库表 components）
  - `type`：器件类别或中文名，例如“开关电源”“导线（含电阻）”。
  - `mark`：器件标识（简称），用于系统描述中引用器件模板与变量占位替换，如`KM`、`FU`、`L`。
  - `parameter`：以逗号分隔的参数名清单，参数默认值保存在表 `parameters`（按`(componentId,name,defaultValue)`）。
  - `variable`：SMTLIB 变量声明，使用占位符`%<mark>%`代表实例名，例如`(declare-fun %FU%.1.i () Real)`。
  - `description`：器件正常模式的约束（若干`(assert ...)`），可包含`%参数名%`占位符与`%<mark>%`占位符。
  - `failuremode`：故障模式定义（XML-like），支持：
    - `<unknownfault><p>概率</p></unknownfault>` 未知故障先验；
    - `<common>...SMT 片段...</common>` 追加到每个已知故障`describe`之前的公共约束；
    - 多个`<fault>`块，含`<name>`、`<p>`、`<describe>`（SMT 片段）。

- 占位替换与实例化
  - 在系统描述中实例化行如`KM KM(Resistance=2200,ActCurrent=0.1,RatedVoltage=220)`：
    - 将组件模板中的`%KM%`替换为实例名`KM`；
    - 将`%Resistance%`等参数替换为实例传入值；若缺省，则回退到表`parameters`中的默认值；
    - 同样规则应用于每个故障模式的`describe`文本；`<common>`文本会自动拼接到每个`describe`之前。

- 变量与端口命名约定
  - 端口电流与电压命名为`.i`与`.u`，例如`L1.1.i`、`L1.1.u`；
  - 支持多端口与多级端口，例如`KM.A1_A2`、`M.A_B`；
  - 支持数组电流`(Array Int Real)`的端口，连接时用`(select X.i 0/1/2)`访问；
  - 可声明内部逻辑/状态变量，如`%SP%.inputok`（Bool）。

- 正常模式与故障模式约束
  - 正常模式：存放于`description`，用于“无故障”基线；
  - 故障模式：来自`failuremode/<fault>/describe`；求解单/多故障时以“移除正常约束 + 叠加对应故障约束”的方式构造候选组合；
  - 未知故障：仅使用`unknownfault.p`参与先验，建模时不指定具体`describe`。

- 先验概率与合成
  - 器件的综合失效先验`Pf = 1 - Π(1-p_i)`，其中`p_i`为未知故障及各已知故障模式的先验；
  - 观测（测试项）的失效概率由置信度通过内置插值函数转换（`calFailureProbabilityFromConfidence`）。

- 案例要点映射（与示例一致）
  - 开关电源`SP`：`variable`声明AC/DC两侧`u/i`及`inputok`；`description`包含能量守恒与输入电压窗口判定，并基于`DC_N.i`分段给出`outuu`；使用`%InputPower%`等参数。
  - 导线`L`：正常约束`Σi=0`、两端等势；故障模式含“导线松动/导线断开”，`<common>`在故障下强制`L.1.i=0`等。
  - 保险丝`FU`：两侧等势、成对电流守恒；故障模式“左位/右位熔断”在`describe`中分别置零对应支路电流。
  - 断路器`QF`：`closed`控制等势/断开时支路电流为0，并含最大电流触发跳闸逻辑。
  - 指示灯`HL`：基于`ActCurrent`与`Resistance`的欧姆关系与点亮阈值，`light`为Bool输出。

- 备注
  - 示例中的`struct`端口清单（如`p1,p2;`）当前实现不从数据库读取；端口由连接语句自动推断到组件实体中（见`ComponentEntity::addPort`）。
  - 设备外观、端口图片等辅佐资料可在文档侧维护，不影响求解。

## 系统模型要素

- 语法结构
  - 组件定义块：`DEF BEGIN ... DEF END`，每行一个实例，形如：`<mark> <实例名>(k1=v1,k2=v2,...)`；
    - `<mark>`指向数据库中的组件模板（表`components.mark`）；
    - `<实例名>`成为该组件在约束中的前缀，并替换模板中的`%<mark>%`；
    - 参数可省略，缺省时按表`parameters`的默认值替换。
  - 连接与原生SMT：定义块之后为连接/原生约束，按行解析：
    - `connect2e(A,B)`：二端节点连接，生成`(assert (= (+ A.i B.i) 0)) (assert (= A.u B.u))`；
    - `connect3e(A,B,C)`：三端节点连接，生成`Σi=0，u等势`；
    - `connect2e(1P,A,B)`/`connect3e(1P,A,B,C)`：一相数组电流端口，使用`(select X.i 0)`；
    - `connect2e(3P,...)`/`connect3e(3P,...)`：三相数组电流端口，对索引0/1/2分别约束；
    - `link(X,Y)`：简化形式，直接生成`(assert (= X Y))`；
    - `rawsmt ( ... )`：原样嵌入任意 SMT 代码；亦支持直接书写`(declare-fun ...)`与`(assert ...)`行。

- 端口与命名
  - 端口通过连接语句隐式注册至组件实例（解析时写入`ComponentEntity`端口集）；
  - 端口命名采用`实例名.端口名`，电气端口使用`.i/.u`；层级端口使用多级点号（如`M.A_B.1`）。

- 求解准备与裁剪
  - 系统描述经`SystemEntity::prepareModel`解析为三段：变量声明、组件正常约束、连接约束；
  - 功能求解前可按功能`link`对描述进行裁剪，仅保留相关组件与连接（见`SystemStructure`）。

- 示例（与所给案例一致）
  - 组件定义：如`KM KM(Resistance=2200,ActCurrent=0.1,RatedVoltage=220)`、`L L1()`、`FU FU()`等；
  - 连接关系：`connect2e(T.A2_B2,L1.1)`、`connect3e(L7.1,L21.1,FU.4)`、`connect2e(KM.4,FR.1)`等；
  - 该语法自动保证连接点的电压等势与电流守恒，三相场景通过数组下标进行逐相约束。

## 功能建模

功能以“所需的输入 + 期望的输出”为核心进行建模，并允许功能之间建立依赖关系。若功能B依赖功能A，则B在建模时可不显式重复A的输入，系统会按依赖关系递归计算得到实际所需输入集合，并在求解前对链路与边界条件进行补全与裁剪。

- 期望输出（功能执行器）
  - 每个功能需至少包含一条“功能执行器”类型的约束，表示该功能的期望输出。例如电机应转动（`M.M1.act = true`）或应停止（`M.M1.act = false`）。
  - 内部求解与完整性检查时，会对“功能执行器”的期望值进行取反以验证约束的完备性：若取反后仍可满足，则说明当前约束不充分；若取反后不可满足（UNSAT），则说明约束能唯一支撑该期望输出。

- 所需输入（观测与边界）
  - 一般变量：来自系统观测或参数，如`QS.closed = true`、`T.A1_B1.u = 220`等。变量类型支持 Bool、Real、(Array Int Real) 等，数值约束既可为离散值，也可为区间、比较式或 SMT 表达式（如`smt(or ...)`）。
  - 边界条件：当前功能链路与外部系统之间的接口变量。可通过“查找边界条件”自动识别；已存在的边界条件会去重保留，缺失的将提示补充。
  - 依赖功能：以“功能正常/功能异常”的方式引用其他功能的输出期望。当前实现中，“功能正常”会在求解前展开为被依赖功能的“执行器变量 = 值”；“功能异常”表达否定关系并在界面提供提示（‘!=’），其展开与求解将逐步完善。

- 链路与裁剪
  - `link`定义功能求解空间（链路），由逗号分隔的器件或端口构成。无点号表示器件全集，包含点号表示具体端口；多级点号表示端口的层级包含关系，例如`FR.1.A`从属于`FR.1`。
  - 链路合并规则（用于依赖功能递归合并）：若已存在父元素，则不再添加子元素；若添加父元素，需吸收并移除已存在的子元素；完全重复不添加。
  - 系统在求解前按链路对系统描述进行裁剪，仅保留涉及链路的器件与连接，提高求解效率并明确边界条件集合。

- 依赖关系（器件/功能）
  - 器件依赖（`component`）：从`link`计算得到当前功能的主链器件列表，遵循链路顺序，末端器件置于列表尾部。界面提供“计算依赖器件”自动生成；也可指定`allComponent`保存全部相关器件（用于排序与补全）。
  - 功能依赖（`function`）：采用“器件,功能,相关端口; ...”三元组串行化存储：
    - 第1列为执行该依赖功能的“执行器器件”（允许为空）；第2列为功能名称（允许为空）；第3列为与该器件相关的端口（用空格分隔，可为空）。三元组中“器件”和“功能”不可同时为空。
    - “自动查找依赖功能”会在当前功能的器件依赖中，匹配那些作为其他功能“执行器”的器件（排除当前功能自身执行器），并补齐功能名及其相关端口。

- 变量约束（`constraint`）
  - 字段：`variable`、`value`、`confidence`、`type`。
  - `type`取值：`一般变量`、`功能执行器`、`边界条件`、`依赖功能`。
  - 置信度默认规则（可在界面调整）：
    - 功能执行器：1.0；一般变量（Bool）：0.5；一般变量（数值类）：0.1；依赖功能：0.1。
  - 数值类变量的取反规则：
    - 常数c → `smt(or (< %1 c) (> %1 c))`
    - 区间(a,b)/[a,b]/(a,b]/[a,b)按边界开闭生成左右侧开集的并集；比较式`>`/`>=`/`<`/`<=`互换方向。

- 离线求解结果（`offlineSolveResult`）
  - 字段：`componentNames`（可为多器件组合）、`failureModes`、`probability`。
  - 用于保存该功能在当前约束下的离线诊断结果与先验概率，界面按单器件非“未知”的结果进行颜色映射，便于人工复核。

- 存储结构
  - 根节点：`<root>`
    - `treestruct`：功能树结构，仅保存节点名称与层级。
    - 多个`functiondefine`：各功能的完整定义（名称、链路、依赖、约束、属性、离线结果、完整性与变量范围样本）。
    - `variableRangeConfig`：全局变量类型范围配置（见“变量取值范围配置”）。
  - 典型片段：
    - `functiondefine/name`：功能名称。
    - `functiondefine/link`：求解空间（链路）。
    - `functiondefine/dependency/function`：功能依赖三元组串。
    - `functiondefine/dependency/component`：主链器件列表。
    - `functiondefine/dependency/allComponent`：全部相关器件。
    - `functiondefine/describe`：功能文本描述。
    - `functiondefine/attribute`：`Persistent|NotPersistent, 失效先验概率`（如 `Persistent,3.281e-04`）。
    - `functiondefine/constraint`：变量约束列表。
    - `functiondefine/constraintIntegrity`：约束完整性评估结果，取值：`完整` | `不完整` | `不正确`。
    - `functiondefine/offlineSolveResult`：离线求解结果集合。
    - `functiondefine/variableValueConfig`：变量样本与可行区间集合；每个`variable`包含：
      - `name`（属性）：变量名（如 `KM.A1_A2.i`、`QS.closed`）。
      - `type`（可选）：变量类型键（如 `i`/`u`/`R`/`F`/`M` 等，布尔省略）。
      - `typical`：典型值（数值或布尔）。
      - `range`：可行区间（数值为`[min,max]`或多段以`;`拼接；布尔为`true;false`或`true`）。
      - `satSamples`：最近一次 SAT 求解样本值（与典型值分离保存）。