# 概述

T-Solver是一款机电液复杂装备故障诊断工具软件。软件基于预先建立的系统诊断模型以及当前的系统观测进行求解，求解得到候选诊断解，即系统中可能的故障器件及其故障模式以及可能错误的观测。同时，软件会根据诊断模型中各器件的先验故障概率以及系统观测的置信度为每个候选诊断解计算可能发生的概率，并按概率从高到低排序，为用户提供直观的故障定位参考。根据当前的候选诊断解集合，软件可进行测点推荐，即根据信息熵、测试代价和测试风险综合推荐下一步的系统观测变量，辅助用户进行故障隔离。用户输入新的观测结果后，软件进行增量求解，缩小候选诊断解的范围。其求解流程支持多轮迭代，直到满足故障隔离要求或人工终止求解过程。软件实现了对复杂装备故障的高效、精准诊断，有效提升了故障处理效率，是装备维修和故障诊断领域的创新性工具。
首先，系统描述包含系统中全部器件（包括导线、液压管路等连接器件）的定义、代号和实例化参数，以及器件间的连接关系,这些系统及器件定义与描述提供了对系统结构和性能的详细认识，为故障诊断提供了基础。
其次，功能描述则包含了系统各功能的简述、链路信息、功能依赖关系、器件依赖关系、所有相关器件、功能相关变量的约束关系、功能失效概率以及离线求解的该功能故障的初始解集等信息。这些信息的提供，确保了软件在进行故障诊断时，能够对系统的功能性能有一个全面的把握，为准确的诊断结果奠定了基础。

# 模型说明

描述语言采用SMTLIB2规范（Satisfiability Modulo Theories Library 2.0，是SMT求解器领域的标准输入输出格式规范，可采用现有的一些成熟求解器进行求解，如本项目使用的微软Z3求解器）。

目前所设计的诊断的框架方法为： 对于每个器件，定义1个正常模式，n个已知故障模式，1个未知故障模式（n≥0），且每个故障模式均定义一个先验的发生概率。每个模式下代数表达式（等式或不等式）描述其相关变量须满足的约束关系。 诊断的过程就是将被诊断功能相关的器件、外部输入、观测对应的变量描述语句放到一起，器件端口之间的连接采用共享变量的方式实现，进行求解看有没有解。其中器件的定义语句是根据器件推定的模式（正常模式/故障模式）来选择的，然后对所有器件的可能模式进行组合（实际工程项目中，不需要列出所有组合，列出概率相对较大的即可），如果在某个器件模式组合下，约束求解器输出结果为有解，则表示当前的这组对器件状态的推定可以解释所观测到的现象。 这样就可以利用约束求解器求解由代数表达式描述的器件约束关系的方式来对系统进行诊断。 诊断框架使用了约束满足性（constraint satisfaction）的方法，使用不同的模式来表示每个器件的不同状态，然后将这些状态的约束与观测结果相结合，用约束求解器（如Z3）来找出能满足所有约束的器件状态。

## 器件模型要素

- 字段结构（数据库表 components）
  - `type`：器件类别或中文名，例如“开关电源”“导线（含电阻）”。
  - `mark`：器件标识（简称），用于系统描述中引用器件模板与变量占位替换，如`KM`、`FU`、`L`。
  - `parameter`：以逗号分隔的参数名清单，参数默认值保存在表 `parameters`（按`(componentId,name,defaultValue)`）。
  - `variable`：SMTLIB 变量声明，使用占位符`%<mark>%`代表实例名，例如`(declare-fun %FU%.1.i () Real)`。
  - `description`：器件正常模式的约束（若干`(assert ...)`），可包含`%参数名%`占位符与`%<mark>%`占位符。
  - `failuremode`：故障模式定义（XML-like），支持：
    - `<unknownfault><p>概率</p></unknownfault>` 未知故障先验；
    - `<common>...SMT 片段...</common>` 追加到每个已知故障`describe`之前的公共约束；
    - 多个`<fault>`块，含`<name>`、`<p>`、`<describe>`（SMT 片段）。

- 占位替换与实例化
  - 在系统描述中实例化行如`KM KM(Resistance=2200,ActCurrent=0.1,RatedVoltage=220)`：
    - 将组件模板中的`%KM%`替换为实例名`KM`；
    - 将`%Resistance%`等参数替换为实例传入值；若缺省，则回退到表`parameters`中的默认值；
    - 同样规则应用于每个故障模式的`describe`文本；`<common>`文本会自动拼接到每个`describe`之前。

- 变量与端口命名约定
  - 端口电流与电压命名为`.i`与`.u`，例如`L1.1.i`、`L1.1.u`；
  - 支持多端口与多级端口，例如`KM.A1_A2`、`M.A_B`；
  - 支持数组电流`(Array Int Real)`的端口，连接时用`(select X.i 0/1/2)`访问；
  - 可声明内部逻辑/状态变量，如`%SP%.inputok`（Bool）。

- 正常模式与故障模式约束
  - 正常模式：存放于`description`，用于“无故障”基线；
  - 故障模式：来自`failuremode/<fault>/describe`；求解单/多故障时以“移除正常约束 + 叠加对应故障约束”的方式构造候选组合；
  - 未知故障：仅使用`unknownfault.p`参与先验，建模时不指定具体`describe`。

- 先验概率与合成
  - 器件的综合失效先验`Pf = 1 - Π(1-p_i)`，其中`p_i`为未知故障及各已知故障模式的先验；
  - 观测（测试项）的失效概率由置信度通过内置插值函数转换（`calFailureProbabilityFromConfidence`）。

- 案例要点映射（与示例一致）
  - 开关电源`SP`：`variable`声明AC/DC两侧`u/i`及`inputok`；`description`包含能量守恒与输入电压窗口判定，并基于`DC_N.i`分段给出`outuu`；使用`%InputPower%`等参数。
  - 导线`L`：正常约束`Σi=0`、两端等势；故障模式含“导线松动/导线断开”，`<common>`在故障下强制`L.1.i=0`等。
  - 保险丝`FU`：两侧等势、成对电流守恒；故障模式“左位/右位熔断”在`describe`中分别置零对应支路电流。
  - 断路器`QF`：`closed`控制等势/断开时支路电流为0，并含最大电流触发跳闸逻辑。
  - 指示灯`HL`：基于`ActCurrent`与`Resistance`的欧姆关系与点亮阈值，`light`为Bool输出。

- 备注
  - 示例中的`struct`端口清单（如`p1,p2;`）当前实现不从数据库读取；端口由连接语句自动推断到组件实体中（见`ComponentEntity::addPort`）。
  - 设备外观、端口图片等辅佐资料可在文档侧维护，不影响求解。

## 系统模型要素

- 语法结构
  - 组件定义块：`DEF BEGIN ... DEF END`，每行一个实例，形如：`<mark> <实例名>(k1=v1,k2=v2,...)`；
    - `<mark>`指向数据库中的组件模板（表`components.mark`）；
    - `<实例名>`成为该组件在约束中的前缀，并替换模板中的`%<mark>%`；
    - 参数可省略，缺省时按表`parameters`的默认值替换。
  - 连接与原生SMT：定义块之后为连接/原生约束，按行解析：
    - `connect2e(A,B)`：二端节点连接，生成`(assert (= (+ A.i B.i) 0)) (assert (= A.u B.u))`；
    - `connect3e(A,B,C)`：三端节点连接，生成`Σi=0，u等势`；
    - `connect2e(1P,A,B)`/`connect3e(1P,A,B,C)`：一相数组电流端口，使用`(select X.i 0)`；
    - `connect2e(3P,...)`/`connect3e(3P,...)`：三相数组电流端口，对索引0/1/2分别约束；
    - `link(X,Y)`：简化形式，直接生成`(assert (= X Y))`；
    - `rawsmt ( ... )`：原样嵌入任意 SMT 代码；亦支持直接书写`(declare-fun ...)`与`(assert ...)`行。

- 端口与命名
  - 端口通过连接语句隐式注册至组件实例（解析时写入`ComponentEntity`端口集）；
  - 端口命名采用`实例名.端口名`，电气端口使用`.i/.u`；层级端口使用多级点号（如`M.A_B.1`）。

- 求解准备与裁剪
  - 系统描述经`SystemEntity::prepareModel`解析为三段：变量声明、组件正常约束、连接约束；
  - 功能求解前可按功能`link`对描述进行裁剪，仅保留相关组件与连接（见`SystemStructure`）。

- 示例（与所给案例一致）
  - 组件定义：如`KM KM(Resistance=2200,ActCurrent=0.1,RatedVoltage=220)`、`L L1()`、`FU FU()`等；
  - 连接关系：`connect2e(T.A2_B2,L1.1)`、`connect3e(L7.1,L21.1,FU.4)`、`connect2e(KM.4,FR.1)`等；
  - 该语法自动保证连接点的电压等势与电流守恒，三相场景通过数组下标进行逐相约束。

## 功能建模

功能以“所需的输入 + 期望的输出”为核心进行建模，并允许功能之间建立依赖关系。若功能B依赖功能A，则B在建模时可不显式重复A的输入，系统会按依赖关系递归计算得到实际所需输入集合，并在求解前对链路与边界条件进行补全与裁剪。

- 期望输出（功能执行器）
  - 每个功能需至少包含一条“功能执行器”类型的约束，表示该功能的期望输出。例如电机应转动（`M.M1.act = true`）或应停止（`M.M1.act = false`）。
  - 内部求解与完整性检查时，会对“功能执行器”的期望值进行取反以验证约束的完备性：若取反后仍可满足，则说明当前约束不充分；若取反后不可满足（UNSAT），则说明约束能唯一支撑该期望输出。

- 所需输入（观测与边界）
  - 一般变量：来自系统观测或参数，如`QS.closed = true`、`T.A1_B1.u = 220`等。变量类型支持 Bool、Real、(Array Int Real) 等，数值约束既可为离散值，也可为区间、比较式或 SMT 表达式（如`smt(or ...)`）。
  - 边界条件：当前功能链路与外部系统之间的接口变量。可通过“查找边界条件”自动识别；已存在的边界条件会去重保留，缺失的将提示补充。
  - 依赖功能：以“功能正常/功能异常”的方式引用其他功能的输出期望。当前实现中，“功能正常”会在求解前展开为被依赖功能的“执行器变量 = 值”；“功能异常”表达否定关系并在界面提供提示（‘!=’），其展开与求解将逐步完善。

- 链路与裁剪
  - `link`定义功能求解空间（链路），由逗号分隔的器件或端口构成。无点号表示器件全集，包含点号表示具体端口；多级点号表示端口的层级包含关系，例如`FR.1.A`从属于`FR.1`。
  - 链路合并规则（用于依赖功能递归合并）：若已存在父元素，则不再添加子元素；若添加父元素，需吸收并移除已存在的子元素；完全重复不添加。
  - 系统在求解前按链路对系统描述进行裁剪，仅保留涉及链路的器件与连接，提高求解效率并明确边界条件集合。

- 依赖关系（器件/功能）
  - 器件依赖（`component`）：从`link`计算得到当前功能的主链器件列表，遵循链路顺序，末端器件置于列表尾部。界面提供“计算依赖器件”自动生成；也可指定`allComponent`保存全部相关器件（用于排序与补全）。
  - 功能依赖（`function`）：采用“器件,功能,相关端口; ...”三元组串行化存储：
    - 第1列为执行该依赖功能的“执行器器件”（允许为空）；第2列为功能名称（允许为空）；第3列为与该器件相关的端口（用空格分隔，可为空）。三元组中“器件”和“功能”不可同时为空。
    - “自动查找依赖功能”会在当前功能的器件依赖中，匹配那些作为其他功能“执行器”的器件（排除当前功能自身执行器），并补齐功能名及其相关端口。

- 变量约束（`constraint`）
  - 字段：`variable`、`value`、`confidence`、`type`。
  - `type`取值：`一般变量`、`功能执行器`、`边界条件`、`依赖功能`。
  - 置信度默认规则（可在界面调整）：
    - 功能执行器：1.0；一般变量（Bool）：0.5；一般变量（数值类）：0.1；依赖功能：0.1。
  - 数值类变量的取反规则：
    - 常数c → `smt(or (< %1 c) (> %1 c))`
    - 区间(a,b)/[a,b]/(a,b]/[a,b)按边界开闭生成左右侧开集的并集；比较式`>`/`>=`/`<`/`<=`互换方向。

- 离线求解结果（`offlineSolveResult`）
  - 字段：`componentNames`（可为多器件组合）、`failureModes`、`probability`。
  - 用于保存该功能在当前约束下的离线诊断结果与先验概率，界面按单器件非“未知”的结果进行颜色映射，便于人工复核。

- 存储结构
  - 根节点：`<root>`
    - `treestruct`：功能树结构，仅保存节点名称与层级。
    - 多个`functiondefine`：各功能的完整定义（名称、链路、依赖、约束、属性、离线结果）。
  - 典型片段：
    - `functiondefine/name`：功能名称。
    - `functiondefine/link`：求解空间（链路）。
    - `functiondefine/dependency/function`：功能依赖三元组串。
    - `functiondefine/dependency/component`：主链器件列表。
    - `functiondefine/dependency/allComponent`：全部相关器件。
    - `functiondefine/describe`：功能文本描述。
    - `functiondefine/attribute`：`Persistent|NotPersistent, 失效先验概率`。
    - `functiondefine/constraint`：变量约束列表。
    - `functiondefine/offlineSolveResult`：离线求解结果集合。

- 建模流程建议
  1) 定义功能名称与“功能执行器”约束（期望输出）；
  2) 指定`link`并“计算依赖器件”，必要时补齐`allComponent`；
  3) 添加一般变量与边界条件（支持模板值，如`AC220_1P_u`、`AC380_3P_i`、`Hydro_p`、`Hydro_f`）；
  4) 通过“自动查找依赖功能”补齐功能依赖，或手工编辑三元组；必要时在约束中加入“依赖功能=功能正常”；
  5) “查找边界条件”补齐必需边界变量；
  6) “检查约束完整性”验证：若提示“完整”，说明约束足以支撑该功能输出；如为“不完整”，请补充约束或依赖；
  7) 视需要进行“离线求解”并保存结果。

上述机制与界面行为对应于源码 widget/selectfunctiondialog.cpp/h/ui：

- 功能树与XML序列化：`updateFunctionTree`、`addTreeItemsFromXML`、`addFunctionToXML`；
- 链路/器件依赖推导：`CalComponentDependency`；
- 功能依赖推导：`CalFunctionDependency`（基于功能-执行器映射`functionActuatorNameMap`与链路端口）；
- 依赖功能展开与链路合并：`recursiveAdd`、`processTestItemListForPenetrativeSolve`；
- 边界条件识别：`SystemStructure.getBoundaryComponentList()`；
- 约束取反与一致性检查：`negateRange`、`on_btn_CheckConstraints_clicked`；
- 离线结果维护与着色：`insertIntoResultTable`、`resultProcessAndUpdateColor`。

# 软件的使用流程

1、打开系统模型，载入系统描述与功能描述
2、选择待诊断的功能
3、输入初始系统观测
4、软件进行完整求解，得到初始诊断解集：候选诊断解。候选诊断解包含两类解，第一类是可能故障的器件或器件组（且解集中还包含每个器件的故障模式，可以是提前建好的已知失效模式，也可以是未知失效模式），第二类是可能错误的观测，观测错误的原因又分为观测可疑（该观测的置信度低于计算出的阈值，阈值由当前第一类解的概率进行计算，如果概率越低，则阈值越高，即越罕见的故障需要置信度越高的观测来支撑）与观测阻滞（即该观测正在阻止得到更高概率的第一类诊断结果）。候选诊断解按概率由高到低进行排序。
5、软件根据信息熵、测试代价、测试风险综合推荐下一步的观测变量
6、人工进行观测后输入观测结果
7、软件进行增量求解，缩小诊断解集的范围
8、循环执行5~7步，直到满足求解结束条件或人工终止求解过程。求解结束条件：无进一步可推荐的观测或者诊断解集已不可继续缩小。
异常观测的判断准则
 1）罕见故障需要置信度高的观测来支持。当前诊断候选解中已知故障的综合概率越低，则需要的置信度阈值应越高。
计算方法：遍历resultEntityList中已知故障模式的单故障,计算其综合故障概率$p_f=1-(1-p_1)*(1-p_2)*...(1-p_n)$，其中$p_n$为第个resultEntityList中已知故障模式的单故障的概率。如果观测的失效概率$p_2$高于pf的1/10，则将其加入outlierObs中。此种情况下观测出现观测错误的综合概率$p=p_2*(1-p_f)$。
 2）如果去掉一个观测，可得到一个概率较高的已知故障的诊断解，则此观测需要进行确认。
计算方法：根据概率由高到低的顺序遍历resultEntityList中的有且仅有1个观测故障b的双故障结果，如果除观测以外的器件故障c为已知故障，且故障概率高于resultEntityList中最可能诊断解概率的1/2，则将这个观测故障加入outlierObs中。观测出现观测错误的综合概率p的计算方法：找到所有包含器件b的singleObsResultEntity，假设有n个，则概率p=1-（1-c1.probability）*（1-c2.probability)*……*(1-cn.probability)，其中cn.probability为第n个singleObsResultEntity中器件c的故障模式概率
这款软件的一个主要技术特点是，它将故障诊断问题转换为约束性满足问题来进行底层求解，同时辅以设备历史运行与诊断数据的深度学习技术，实现了对复杂装备故障的高效、精准诊断。深度学习技术使得软件能够根据历史故障数据学习故障模式，而智能推理则为确定故障源提供了一种逻辑推断的方法。这两种技术的结合，使得软件在进行故障诊断时，既能考虑历史数据，也能参照逻辑推理，从而极大地提高了诊断的准确性和效率。
另一个技术特点是，该软件能够根据当前的故障模式和观测数据，推荐最可能的故障源和下一步的观测变量。这一点在大大提高了诊断效率的同时，也减少了故障诊断过程中的不确定性。
总的来说，这款软件的开发目的是为了解决复杂装备的故障诊断问题，其设计理念是将深度学习和智能推理技术结合起来，以提高故障诊断的准确性和效率。在具体的操作流程上，它采取了一种逐步求解和优化的策略，既保证了最终结果的准确性，也满足了用户对故障诊断效率的需求。此外，软件在设计上还考虑到了用户体验，不仅提供了直观的操作界面，还根据用户的操作和输入，智能地提供了最可能的故障源和下一步的观测建议，这提高了用户的工作效率。
诊断框架使用了约束满足性（constraint satisfaction）的方法，使用不同的模式来表示每个器件的不同状态，然后将这些状态的约束与观测结果相结合，用Z3求解器来找出能满足所有约束的器件状态。
这个方法的优点是它可以考虑大量的信息和可能性，同时还可以使用强大的约束求解器来找出可能的解。但是，它也面临一些挑战。比如组合爆炸的问题，如果系统较多，那么可能的状态组合就会非常多，会超出求解器的处理能力。此外，这种方法还需要你能够准确地描述出每个器件在每个模式下的行为的约束关系，这在实际情况中可能并不容易做到。当前的方案并未考虑时间的因素，只考虑静态的状态，所以对于一些积分、微分的约束关系以及状态的时序逻辑并未直接考虑。
同时，也有一些解决方案，比如可只考虑单故障与双故障等概率相对较大的器件模式组合，这可以显著减少需要处理的状态数量。此外，也可考虑使用一些启发式的方法，来进一步减少需要考虑的状态。在测点推荐过程中，可根据系统的拓扑结构，优先从系统连接网络路径上的中点开始计算测试推荐的目标函数Si，以此来优化测点推荐的计算速度。
总之，当前的断框架是基于合理的原理和方法的，它是一个很好的起点。在编程实现与实际使用中，需要根据工程应用中的具体情况和需求来进行调整和优化。
