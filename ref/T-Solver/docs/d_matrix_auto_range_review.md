# 信号自动区间推导修复说明与测试指引

本说明面向刚接手 T-Solver 项目的开发者，旨在帮助理解“信号自动区间推导”修复的背景、原理、示例以及完整的手动测试流程。内容紧扣《测试性建模技术》文档中关于测试性模型构建的概念，结合项目内 QBT 与 Hydro 两个典型系统场景，力求以通俗、逐步拆解的方式阐明整体思路。

## 1. 背景与总体目标

- **总体目标回顾**：针对任意给定的系统 SMT 描述（包含器件、连接、功能与观测约束），自动构建测试性模型（D 矩阵），即判断每个测试是否能够检测到每种故障。【F:docs/测试性建模技术.md†L1-L72】
- **当前修复聚焦**：P2 阶段的“自动规范推导”子模块，其任务是为每个信号测试自动推导一个上下界区间，作为测试判据的一部分。区间需要足够精确，既不能错判受限变量为“无界”，也不能错失有效测试。

## 2. 问题成因与修复概述

### 2.1 原始问题

早期实现中，对信号下界的可行性校验采用了如下思路：
1. 固定一个“全局搜索范围”`[-searchMaxAbs, +searchMaxAbs]`，默认是一个对所有模型通用的较大区间（例如 ±1e6）。
2. 在正式二分搜索之前，通过添加断言 `expr <= -searchMaxAbs` 进行可行性检测。如果这个断言满足，则认为变量存在“比全局下界更小的值”，从而判定变量“无界”，直接放弃生成测试。

问题在于：当模型中存在独立的约束（例如功能输入、设备物理极限）已经禁止变量进入 `[-searchMaxAbs, +searchMaxAbs]` 之外的区域时，上述判断会错误地得出“可行”。具体的错误步骤是：
- 在 Z3 中，断言 `expr <= -searchMaxAbs` 与其他约束组合后仍然可以找到模型（SAT），仅仅因为其他变量尚未被完全约束；
- 代码据此认为“变量可以小到 -searchMaxAbs 以下”，判定变量下界不可得，提前退出，导致后续测试缺失。

### 2.2 修复思路

修复后的代码（`computeAutoRange` 函数）采用了更谨慎的顺序：
1. **先检查上界**：若 `expr >= +searchMaxAbs` 在正常模型中是可行的，说明变量可能超过全局上界，此时认定区间不可自动推导（返回空结果）。
2. **再检查下界**：只有在确认上界不可越过后，才检查 `expr <= -searchMaxAbs` 是否可行；若仍然 SAT，则仍认定“可能无界”，返回空结果。
3. **二分搜索**：如果两个方向的极端值都不可行，则在 `[-searchMaxAbs, +searchMaxAbs]` 范围内进行二分搜索，独立寻找满足 `(>= expr mid)` 和 `(<= expr mid)` 的最紧上/下界。【F:testability/d_matrix_builder.cpp†L90-L128】
4. **结果整理**：最终得到的 `[lower, upper]` 区间被标记为 `source=auto`，表示来自自动推导流程。【F:testability/d_matrix_builder.cpp†L130-L135】

这样处理后，只有在模型确实允许变量突破我们设定的搜索边界时才会放弃生成测试，避免了“明明被约束住却被误判为无界”的情形。

## 3. 示例解析：为什么修复有效

以下示例均基于真实项目背景中常见的两类系统：

### 3.1 Hydro 液压泵站示例

- **变量场景**：Hydro 模型中的压力传感器 `HPump.p`（模板键 `Hydro_p`）通常在 0~25 MPa 之间工作，功能输入约束会给出如 `HPump.p ∈ [10, 22]` 的范围。
- **错误前的表现**：早期版本在检查下界时，向 Z3 提出 `(<= HPump.p -1000000)`。由于模型里没有明确说明“压力不可能为 -1e6”，求解器会找到一个满足所有约束的解：让其他未约束变量取极端值，使约束暂时成立，导致系统误判 HPump.p “可能无界”，跳过该信号测试。
- **修复后的表现**：首先 `(>= HPump.p 1000000)` 会因为与 `HPump.p ≤ 25` 的物理约束冲突而返回 UNSAT，说明上界安全；接着再检测 `(<= HPump.p -1000000)` 时，Z3 结合现有的输入约束也会给出 UNSAT。于是程序进入二分搜索阶段，最终推导出 `[10, 22]` 左右的区间，生成有效的压力测试。

### 3.2 QBT 三相桥臂（QBT）示例

在电力电子的 QBT 模型中，三相输出电压 `QBT.Inverter.u` 采用数组变量表示：`(select QBT.Inverter.u 0/1/2)` 对应 A/B/C 三相。

- **变量场景**：在额定工况下，每相电压应在 `[-311, +311]` V（对应线电压 380 V）。模型中已有约束：`abs(QBT.Inverter.u_phase) ≤ 320`。
- **错误前的表现**：检查 `(<= (select QBT.Inverter.u 0) -1000000)` 时，求解器可能“任意”赋值给其他数组索引，短暂满足断言，从而得出“可能低于 -1e6 V” 的错误结论，全流程跳过该相电压的测试。
- **修复后的表现**：当我们先执行 `(>= (select QBT.Inverter.u 0) 1000000)` 时，模型立即返回 UNSAT，因为与额定约束矛盾；随后 `(<= ... -1000000)` 同样 UNSAT，于是程序继续进行逐相二分搜索，并得到近似 `[-311, 311]` 的区间，为 D 矩阵提供三条信号测试。

通过这两个场景可以看到：修复的核心是“只有在极端值真正可行时才放弃搜索”，从而保护了所有受约束变量生成测试的机会。

## 4. 代码审查与理论一致性（逐段说明）

### 4.1 SMT 封装与模型分解（P0）
- `SmtFacade::buildNormalCode()`/`buildFaultCode()` 将系统实体拆解为“公共变量与连接约束”+“正常/故障器件约束”拼接 SMT 代码，这与《测试性建模技术》中对“模型驱动求解”的描述保持一致：先构造完备的正常模型，再替换局部故障模式。【F:testability/d_matrix_builder.cpp†L90-L118】【F:docs/测试性建模技术.md†L101-L180】
- `isSat()` 对外提供统一的可满足性查询接口，使上层模块可以反复调用而不需要处理 Z3 的细节，契合文档中“求解器作为黑盒判定器”的建议。

### 4.2 故障与测试采集（P1）
- `collectFunctionFaults()` 遍历功能约束，组合“输入断言 + 执行器取反”，正对应文献定义的功能故障模型：在相同输入下，将执行器约束翻转即代表该功能失效的行为。【F:testability/d_matrix_builder.cpp†L141-L189】【F:docs/测试性建模技术.md†L182-L236】
- `collectFunctionTests()` 提取执行器约束的正向表达式作为 `P_t`，并通过 `negateRange` 得到 `Fail_t`。这与理论中“测试 = 判定条件 + 对立条件”的语义一致。

### 4.3 信号测试生成与区间推导（P2）
- `collectSignalTests()` 遍历系统结构内的端口，针对标量和数组变量分别生成测试条目，并调用 `computeAutoRange`、`computeTemplateRange`。该流程完全映射到文献中的“自动化测试规范推导”步骤。【F:testability/d_matrix_builder.cpp†L191-L294】【F:docs/测试性建模技术.md†L237-L328】
- 修复后的 `computeAutoRange` 保证：只要模型给出的极值不超出搜索边界，就进入二分搜索，这与理论中的“根据模型推导最紧区间”一致；若搜索失败，则回退到模板容差策略，满足工程需要。

### 4.4 可检测性判定与 D 矩阵构建（P3）
- `detectability()`（未在本次改动中展示）会对每个测试-故障组合在 Guaranteed / Exists 模式下调用两次 SAT 判定，确保“正常不误报、故障必报”或“存在区分样本”两个语义，这正是 D 矩阵布尔值的理论基础。
- `buildDMatrix()` 使用并发执行与 SAT 缓存，保证大规模矩阵计算的效率，与文档中关于“矩阵规模可达 10k×300”的性能要求相吻合。

通过上述逐段对应，可以确信当前代码实现与既定理论框架保持一致，修复也没有破坏其他模块的契合关系。

## 5. 手把手测试指引（覆盖实现计划）

以下步骤按照 P0~P4 的 ToDo 列表组织，每条指令都给出了操作方式、预期结果与可观察的日志/文件，便于刚入手的同事逐项验证。

### 5.1 P0 基础设施

1. **启动 Hydro 最小示例（验证 SMT 封装）**
   - 打开终端运行：`./T-Solver --testability-demo`（或在 Qt Creator 中设置相同命令行参数运行）。
   - 观察输出日志中是否出现 `[Hydro示例]` 片段，以及“正常模型 + Fail_t SAT”“故障模型 + P_t SAT”“Guaranteed”三行信息。
   - 若日志不存在，可在 `testability/demo_runner.cpp` 中设置断点，确认 `SmtFacade` 构造与 `isSat()` 调用过程。

2. **检查 SMT 代码拼接**
   - 在 `testability` 目录下临时添加调试输出（或使用 `qDebug()`），打印 `buildNormalCode()` 与 `buildFaultCode()` 的返回值。
   - 核对生成代码是否包含：变量声明、正常组件约束、故障注入片段。

### 5.2 P1 测试/故障采集

3. **功能故障元数据校验**
   - 通过 UI 打开任一功能（例如 Hydro 的“功能1_马达正转”），点击“生成 D 矩阵”。
   - 在输出目录 `docs/DMatrix/` 中查找最新的 metadata JSON，确认 `faults` 数组内包含 `inputAssertions` 与 `faultAssertions`，并带有功能名称。

4. **功能测试取反验证**
   - 在同一 metadata 中检查 `tests` 数组的 `kind=function` 项，确认 `predicate` 与 `negatedPredicate` 分别对应正/反向断言。

5. **信号测试覆盖度**
   - 查看 metadata 中 `kind=signal` 的条目，确认 `sourceVariable` 遍历了 `SystemStructure` 的端口，Hydro 场景下应至少出现 `HPump.p`、`HPump.f` 等变量。

### 5.3 P2 规范推导与取反

6. **验证自动区间结果（Hydro）**
   - 在生成 metadata 时开启“自动规范推导”，定位 `source="auto"` 的信号测试，记录其 `[lower, upper]`。
   - 将这些区间与功能约束（如功能 XML 中的压力/流量范围）对照，确认数值量级合理。

7. **模板回退路径**
   - 在 UI 的高级选项中关闭“自动规范推导”，只启用模板。
   - 重新生成 D 矩阵，确认信号测试依然存在，但 `source` 变为 `template:Hydro_p` 等。

8. **数组端口逐相推导（QBT）**
   - 切换到 QBT 模型（若数据库已有该系统），生成 D 矩阵。
   - 检查 metadata 中是否出现 `QBT.Inverter.u[0]`、`[1]`、`[2]` 等条目，并观察各自区间是否独立。

### 5.4 P3 D 矩阵构建与导出

9. **判定模式差异**
   - 在高级选项中分别选择 Guaranteed 与 Exists 模式，各生成一次 D 矩阵。
   - 对比两份 metadata 的 `cells` 数组，Guaranteed 模式应更严格（检测数更少或相同）。

10. **并发与缓存观察**
   - 连续两次生成同一模型的 D 矩阵。
   - 第二次运行时，终端日志应显示更短的耗时（命中 SAT 缓存），系统监视器中 CPU 占用也会下降。

11. **导出文件完整性**
   - 打开 `docs/DMatrix/` 目录，确认 CSV 与 metadata JSON 均生成，且 CSV 的行列数量与 `faults/tests` 数量一致。

### 5.5 P4 UI 与配置

12. **入口与路径设置**
   - 在主界面点击“生成 D 矩阵”，使用弹出的文件对话框选择自定义保存路径，确认输出文件写入正确位置。

13. **高级选项生效性**
   - 反复切换“自动规范推导”“模板回退”“超时”等选项，每次生成后对比 metadata 中的 `options` 字段，确认记录的布尔值与 UI 操作一致。

14. **D 矩阵查看器功能**
   - 打开新建的“D 矩阵查看器”窗口，检查：
     - 表格是否以小方块/颜色展示 0/1；
     - 悬停是否显示 tooltip；
     - 在检索框输入 `t12` 或 `f33` 是否高亮对应行/列；
     - 导出按钮是否能将当前筛选结果另存为 CSV。

完成以上 14 步后，可全面验证修复后的自动区间推导逻辑与整套 D 矩阵构建流程的正确性。

## 6. 小结

- 修复后的 `computeAutoRange` 仅在极端值可行时才提前退出，避免对受限变量误判“无界”。
- Hydro、QBT 两个示例展示了修复对典型液压、电力电子场景的保护效果。
- 手动测试清单覆盖了 P0~P4 的关键功能，便于逐项复核并理解系统工作流程。

如需进一步了解理论背景，可继续参阅《测试性建模技术》全文，以及 `docs/testability/architecture.md` 中的架构说明。
