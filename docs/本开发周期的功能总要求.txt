现在需要对我github中的T-Designer项目增加功能，请仔细研究每一项，并给出更细化的文字描述（类似于完整、细致的软件需求规格说明，而且要奔着最终可落地的代码级实现方案的目标去写），如有需要我澄清或者讨论的地方请列举出来，并给出一些合理的参考建议， 
一、
实现复杂系统的分层模型；层次包括：系统、子系统、LRU、SRU、模块、子模块、元件；现有软件中插入到图纸中的每一个"元件"默认对应为元件级，然后系统可以再建立不同层次的容器，现有软件中的实体"元件"不能同时出现在多个同一层次的容器中，某一个低层级的容器也不能同时出现在多个同一层次的高层级容器中，用户可通过软件界面方便地进行层次化的建模。各层级容器的数据模型可以借鉴树状图。每个容器都有：接口定义，功能行为描述，其中功能行为描述中包括一个正常状态模式与多个故障模式以及一个未知故障(未知故障相当于不对元件功能行为做任何约束，所以不用显式建模)，每个实体“元件”只能处于一种状态。
比如一个实体“元件”继电器K1，被插入到系统中，默认会自动为其生成一个同名元件层的容器，这个元件层由于有且只有K1，所以这个元件层容器可以直接根据继电器K1现有的接口描述（功能子块）、功能行为描述（元件T语言）来生成自己的接口描述与功能行为描述。如果这个系统只有一个实体“元件”，则在元件层上面可以再建立一个系统层（元件层容器可以直接被系统层容器包含，中间的层级可以没有，但被包含的容器的层级一定比当前容器的层级低），系统层在逻辑层面的描述（接口与功能行为）直接就与元件层的一致；现增加一个实体“元件”电磁铁YV1，默认会自动为其生成一个同名元件层的容器，YV1和K1共同构成了一个子系统，则可以在系统层下面增加一个子系统层，包含K1和YV1的元件层容器。此时子系统层的容器的接口与功能行为描述就需要根据两个元件容器的描述来自动生成，这里需要设计一个算法，可以用一个整合后的描述（接口、功能行为）去等效替代各子容器的一个综合效果。被包含子容器的之间相互连接的接口（如果都是内部容器间的接口相连，不涉及高层级容器之外的容器）则在高层级容器里就变成了内部接口，也就是自身功能行为的一部分，对外就不用体现这个内部接口。高层级容器的故障模式也是根据低层级的故障模式总结而来，用户可设定容器的故障模式分析层级，默认是本层级，同时用户也可将其设为比当前容器层级更低的层级，设到哪一级，就分析到哪一级（也就是以当前容器中设定的低层级容器直接参与分析计算，而不是直接使用整合好的高层级容器）。如果一个较高层级容器只包含一个低层级的容器，则直接原封不动地继承其所有特性，如果包含二个或多个低层级的容器，则自身的状态就整合为正常、故障两种，多个容器整合后就没有未知模式了（即此时就只有正常模式，以及正常模式的反面），因为整合后容器就只描述正常的功能行为，非正常的即为故障。具体的整合方法（等价化简与消元）需要仔细考虑与设计。
这么做的目的一是方便在不同的层级对系统进行分析，二是在分析大规模系统时软件会有更好的性能表现。这里需要考虑的另一个核心问题即容器的接口应如何定义、描述，容器自身的功能、行为应如何描述。我们在这里可以重新对此进行设计，以方便我们实现更高级别的软件功能，对于原有系统中的实体“元件”只需要进行一次转换即可。
如果把多个模块进行整合在一起，能否使用z3定理证明器得到这些模块整合在一起的等效功能、行为描述？（相当于每个模块有语句或公式对其进行描述，将多个模块的语句/公式合在一起后，能否使用z3定理证明器进行符号运算，对整合的结果化简）请结合代码分析来给出建议。模块描述现在用的是smt语法，请分析为了实现上述功能的具体代码实现细节。

现有的实体“元件”的smt描述例子：
"电流流出器件为负，流入器件为正"
"电机""MD"
"Resistance=22"
"OutputF=-1200"
"ActCurrent=0.8"
"RatedVoltage=220"

"变量定义"
(declare-fun %MD%.M1.act () Bool)
(declare-fun %MD%.M1.F () Real)
(declare-fun %MD%.M1.M () Real)
(declare-fun %MD%.A_B.u () Real)
(declare-fun %MD%.A_B.i () Real)
(declare-fun %MD%.A_B.R () Real)

"正常模式"
(assert (= %MD%.A_B.R %Resistance%))
(assert (= (* %MD%.A_B.i %MD%.A_B.R) %MD%.A_B.u))
(assert (ite (and (>= %MD%.A_B.u (* %RatedVoltage% 0.8)) (<= %MD%.A_B.u (* %RatedVoltage% 1.2))) (= %MD%.M1.act true) (= %MD%.M1.act false)))
(assert (ite (= %MD%.M1.act true) (and (> %MD%.M1.M 0) (> %MD%.M1.F 0)) (= %MD%.M1.M 0)))

"故障模式"
<unknownfault>

<p>5.0e-7</p>
</unknownfault>
<common>
(assert (= (* %MD%.A_B.i %MD%.A_B.R) %MD%.A_B.u))
(assert (= %MD%.M1.act false))
(assert (= %MD%.M1.M 0))
</common>
<fault>
<name>绕组开路</name>
<p>2.0e-6</p>
<describe>
(assert (> %MD%.A_B.R 100000000))
</describe>
</fault>
<fault>
<name>转轴卡滞</name>
<p>1.0e-5</p>
<describe>
(assert (= %MD%.A_B.R %Resistance%))
</describe>
</fault>


二、
用户工作流程：
1、根据实际系统的硬件组成在工程文件中增加各实体“元件”
2、给系统定义功能，按“所需的输入+期望的输出”模式定义功能，（特定器件的特定输出或特定输出范围即可定义为一个功能），功能与功能之间可以存在依赖关系，如果B功能依赖A功能，则B功能在定义输入时，可以不显式定义A功能所需的输入（系统可以动态计算得到实际所需的输入）。系统的故障即定义为功能失常（输入符合要求但实际输出与期望的输出不符）。
3、在实际硬件组成的基础上建立分层模型
4、在元件层的最详细的模型中，让软件自动创建所有可用的测试，这里也需要仔细思考，如何给出，共有3类测试：
1）信号类测试：根据模型中各接口处的信号类型直接给出，比如系统中共有10个接口，5个电气接口（电压、电流），4个液压接口（油压、流量），1个机械接口（速度、位移），则共有20个可用接口。每类接口的可用测试可以统一定义，针对特定接口还可以手动修改。如何确定某处信号类测试是否能测到某一个故障，需要仔细设计一个高效的算法来实现。
2）功能类测试：属于虚测试（就是理论上存在的测试，不考虑具体的测试实现方式），此类测试可以直接测出功能是否正常，默认针对每个功能创建一个功能类测试；
3）故障模式测试：属于虚测试，此类测试可以直接测试某元件是否处于特定的故障模式，又可细分为：正常判别测试（即可测出模块是否正常），特定故障模式测试（即可测试元件是否处于某一特定的故障模式），默认对每个元件创建一个正常判别测试。如何确定某个元件的正常判别测试是否能测到某一个故障：假设该元件正常判别测试不通过，同时设故障对应的功能正常，各变量的取值都在合理范围内（防止SMT求解器找到在数学上满足但在实际中根本不可能取到的值），看约束满足性问题是否解为可满足。
4）自动创建所有可用测试后，用户可对创建的可用测试进行增、删、改、查等操作
5、根据系统模型建立测试性模型（依赖矩阵，又称为D矩阵，是一种经典的测试性模型）
6、用户对在指定的系统层级输入要求的测试性指标（故障检测率、故障隔离率），软件可以按要求对高层级上的指标分解到其所属的各低层级的容器上
7、在用户指定的层级和范围上，用户指定多维度的约束，例如测试复杂性、测试费用、测试时间等、在测试性指标输入及测试性模型的基础上选出候选测试
8、在用户指定的层级和范围上，基于测试性模型，对候选测试集的测试性指标（故障检测率、故障隔离率）进行预计
9、在用户指定的层级和范围上，基于测试性模型，在候选测试集的基础上生成故障诊断决策树
可以重点参考已有的一些测试性建模及分析软件（尤其是从第5步开始，因为都是一些比较传统的方法），例如美国QSI公司的TEAMS、美国DSI公司的eXpress。
当前版本代码中有部分功能可能已经实现了，但你要完整梳理一遍，确保各模块的功能都是正确的，各模块之间的功能和接口都是匹配的，确保整体功能、流程的完整、正确实现