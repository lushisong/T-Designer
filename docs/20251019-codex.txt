用户工作流程：
1、根据实际系统的硬件组成在工程文件中增加各实体“元件”
2、给系统定义功能，按“所需的输入+期望的输出”模式定义功能，（特定器件的特定输出或特定输出范围即可定义为一个功能），功能与功能之间可以存在依赖关系，如果B功能依赖A功能，则B功能在定义输入时，可以不显式定义A功能所需的输入（系统可以动态计算得到实际所需的输入）。系统的故障即定义为功能失常（输入符合要求但实际输出与期望的输出不符）。
3、在实际硬件组成的基础上建立分层模型
4、在元件层的最详细的模型中，让软件自动创建所有可用的测试，这里也需要仔细思考，如何给出，共有3类测试：
1）信号类测试：根据模型中各接口处的信号类型直接给出，比如系统中共有10个接口，5个电气接口（电压、电流），4个液压接口（油压、流量），1个机械接口（速度、位移），则共有20个可用接口。每类接口的可用测试可以统一定义，针对特定接口还可以手动修改。如何确定某处信号类测试是否能测到某一个故障，需要仔细设计一个高效的算法来实现。
2）功能类测试：属于虚测试（就是理论上存在的测试，不考虑具体的测试实现方式），此类测试可以直接测出功能是否正常，默认针对每个功能创建一个功能类测试；
3）故障模式测试：属于虚测试，此类测试可以直接测试某元件是否处于特定的故障模式，又可细分为：正常判别测试（即可测出模块是否正常），特定故障模式测试（即可测试元件是否处于某一特定的故障模式），默认对每个元件创建一个正常判别测试。如何确定某个元件的正常判别测试是否能测到某一个故障：假设该元件正常判别测试不通过，同时设故障对应的功能正常，各变量的取值都在合理范围内（防止SMT求解器找到在数学上满足但在实际中根本不可能取到的值），看约束满足性问题是否解为可满足。
4）自动创建所有可用测试后，用户可对创建的可用测试进行增、删、改、查等操作
5、根据系统模型建立测试性模型（依赖矩阵，又称为D矩阵，是一种经典的测试性模型）
6、用户对在指定的系统层级输入要求的测试性指标（故障检测率、故障隔离率），软件可以按要求对高层级上的指标分解到其所属的各低层级的容器上
7、在用户指定的层级和范围上，用户指定多维度的约束，例如测试复杂性、测试费用、测试时间等、在测试性指标输入及测试性模型的基础上选出候选测试
8、在用户指定的层级和范围上，基于测试性模型，对候选测试集的测试性指标（故障检测率、故障隔离率）进行预计
9、在用户指定的层级和范围上，基于测试性模型，在候选测试集的基础上生成故障诊断决策树
可以重点参考已有的一些测试性建模及分析软件（尤其是从第5步开始，因为都是一些比较传统的方法），例如美国QSI公司的TEAMS、美国DSI公司的eXpress。

以上是用户的工作流程，现在需要在软件中实现该工作流程，有些模块、功能可能已经实现了，但你也要再捋一遍，确保各模块的功能都是正确的，各模块之间的功能和接口都是匹配的，整体上是可以无缝衔接，完美的实现所有的需求与功能，可以在软件中实现并演示最基本的工作流程，下面是决策要求：
我先睡觉了，所有产品和技术决策由你来掌控，明早我来验收成果
- 大概睡8小时，所以不要急着出结果，所有细节你慢慢做，不要节约token，做对最重要
- 遇到不确定的功能需求，可以先仔细分析各种可能，并按最科学合理的来，还可以参考TEAMS和eXpress软件的做法
- 在具体代码上，如果遇到不确定的，先查一下MCP context7里的文档，还不确定地，网上搜索一下
- 所有子任务分阶段执行，每个阶段完了都跑一下单测，以免全搞完了发现不行要推倒重来
- 你搞定功能就行,界面有基本的就绪，UI部分不要纠结，尽量用Qt桌面软件中的主流通俗写法，明天我来打磨细节


现在你需要仔细阅读代码，弄清楚实体元件的元件属性对话框中"功能子块"tab页中的端口号（同一个功能子块的多个端号用"|"分隔）与CAD绘图中端口之间的连线是如何建立联系的（这部分的功能可能在之前已经实现了，你需要先确认一下）；实体元件的端号如何同实体元件的T语言模型（smt描述）中定义的变量相关联，需要设计一个算法逻辑去关联，并给出器件的smt描述的编写规范。同时设计T语言模型的校验功能，检查T语言模型是否满足规范，检查smt描述中的变量是否与端号关联上了。这里要考虑一个大系统中同一型号的器件可能会有多个（相当于库里的器件的多个实例，如果不专门去修改这些实例化器件的T语言模型、端号，他们元件属性中的端号、T语言模型会是一模一样的）。
以上是需求，下面是决策要求：
我先睡觉了，所有产品和技术决策由你来掌控，明早我来验收成果
﹣大概睡8小时，所以不要急着出结果，所有细节你慢慢做，不要节约token，做对最重要
﹣遇到不确定的功能需求，可以先仔细分析各种可能，并按最科学合理的来，还可以参考TEAMS和eXpress软件的做法
- 在具体代码上，如果遇到不确定的，先查一下MCP context7里的文档，还不确定地，网上搜索一下
﹣所有子任务分阶段执行，每个阶段完了都跑一下单测，以免全搞完了发现不行要推倒重来
﹣UI部分不要纠结，尽量用Qt桌面软件中的主流通俗写法，明天我来打磨细节，你重点搞定功能，界面有基本的就行

这几个流程应按需要设计所需的界面和具体的功能实现：
5、根据系统模型建立测试性模型（依赖矩阵，又称为D矩阵，是一种经典的测试性模型）
6、用户对在指定的系统层级输入要求的测试性指标（故障检测率、故障隔离率），软件可以按要求对高层级上的指标分解到其所属的各低层级的容器上；
7、在用户指定的层级和范围上，用户指定多维度的约束，例如测试复杂性、测试费用、测试时间等、在测试性指标输入及测试性模型的基础上选出候选测试，且用户可在系统自动推荐的基础上进行手动修改；
8、在用户指定的层级和范围上，基于测试性模型，对候选测试集的测试性指标（故障检测率、故障隔离率）进行预计；
9、在用户指定的层级和范围上，基于测试性模型，在候选测试集的基础上生成故障诊断决策树；


现在系统建模时的功能管理的逻辑、界面是在selectfunctiondialog.cpp/h/ui中，这部分是单独开发的，现在只是生硬地强行把这部分的界面加到T-Designer里面了，接口、数据等都是不通的（数据都是单独的一个数据问题，我已复制到./ref/Model.db,供你参考），现在selectfunctiondialog中是重新手动建模，手动为每个器件编写smt描述，手动描述器件之间的连接关系，没有与T-Designer打通（按理说在现有的T-Designer中插入模块、绘制功能子块后连线后应可以自动生成系统描述，包括器件smt描述、器件之间的连接关系等）。需要参照已有的这部分代码，及其界面要素、操作逻辑、业务逻辑，在T-Designer中进行根据具体的接口进行重构，集成到现有的界面与业务逻辑中来（参考、学习并根据需要重构selectfunctiondialog中的内容，但不要直接在selectfunctiondialog上面改，原来的文件保留，然后新建文件，从头设计，重新实现）。
系统功能建模与管理的相关界面主要有两块：
1）在treeViewUnits中选定一实体元件的功能子块，在右键菜单中可以对其创建功能（新建功能对话框），具体的业务逻辑与关键需求可以参考selectfunctiondialog中的实现。
2）在主界面的"设计"栏下面，增设一个"功能管理"按钮（设在"层次模型"按钮右边），点击后弹出系统功能管理窗口，列出所有的功能，并可进行增（弹出对话框，复用treeViewUnits控件，供用户选择功能 子块，后面流程与上一条就是一样的了）、删、改、查等操作。新建、修改操作最好能尽量复用代码、界面与操作逻辑。
以上开发需求，下面是决策要求：
我先睡觉了，所有产品和技术决策由你来掌控，明早我来验收成果
﹣大概睡8小时，所以不要急着出结果，所有细节你慢慢做，不要节约token，做对最重要
﹣遇到不确定的功能需求，可以先仔细分析各种可能，并按最科学合理的来
- 在具体代码上，如果遇到不确定的，先查一下MCP context7里的文档，还不确定地，网上搜索一下
﹣需要花大量的时间用于任务分解，这部分不要怕浪费时间，正所谓磨刀不误砍柴工，分解后的子任务在做完后需要进行检查，以免全搞完了发现不行要推倒重来
﹣你搞定功能就行,界面部分不要纠结，有基本的就可以，尽量用Qt桌面软件中的主流通俗写法（我的Qt版本为5.12），明天我来打磨细节



我现在需要尽快实现全部的工作流程，各步骤的流程与主要界面都不能少，各步骤的基本原理、方法要正确，但在具体实现上可以先实现最简单的一种情况（但设计接口时要考虑周全，要为后面的进一步细化与扩展开发留好空间与接口）。当前阶段就是尽快把全部的工作流程跑通，每个步骤的细化、扩充、完善放到下一个阶段中去实现。
用户工作流程：
1、根据实际系统的硬件组成在工程文件中增加各实体“元件”
2、给系统定义功能，按“所需的输入+期望的输出”模式定义功能，（特定器件的特定输出或特定输出范围即可定义为一个功能），功能与功能之间可以存在依赖关系，如果B功能依赖A功能，则B功能在定义输入时，可以不显式定义A功能所需的输入（系统可以动态计算得到实际所需的输入）。系统的故障即定义为功能失常（输入符合要求但实际输出与期望的输出不符）。
3、在实际硬件组成的基础上建立分层模型
4、在元件层的最详细的模型中，让软件自动创建所有可用的测试，这里也需要仔细思考，如何给出，共有3类测试：
1）信号类测试：根据模型中各接口处的信号类型直接给出，比如系统中共有10个接口，5个电气接口（电压、电流），4个液压接口（油压、流量），1个机械接口（速度、位移），则共有20个可用接口。每类接口的可用测试可以统一定义，针对特定接口还可以手动修改。如何确定某处信号类测试是否能测到某一个故障，需要仔细设计一个高效的算法来实现。
2）功能类测试：属于虚测试（就是理论上存在的测试，不考虑具体的测试实现方式），此类测试可以直接测出功能是否正常，默认针对每个功能创建一个功能类测试；
3）故障模式测试：属于虚测试，此类测试可以直接测试某元件是否处于特定的故障模式，又可细分为：正常判别测试（即可测出模块是否正常），特定故障模式测试（即可测试元件是否处于某一特定的故障模式），默认对每个元件创建一个正常判别测试。如何确定某个元件的正常判别测试是否能测到某一个故障：假设该元件正常判别测试不通过，同时设故障对应的功能正常，各变量的取值都在合理范围内（防止SMT求解器找到在数学上满足但在实际中根本不可能取到的值），看约束满足性问题是否解为可满足。
4）自动创建所有可用测试后，用户可对创建的可用测试进行增、删、改、查等操作
5、根据系统模型建立测试性模型（依赖矩阵，又称为D矩阵，是一种经典的测试性模型）
6、用户对在指定的系统层级输入要求的测试性指标（故障检测率、故障隔离率），软件可以按要求对高层级上的指标分解到其所属的各低层级的容器上
7、在用户指定的层级和范围上，用户指定多维度的约束，例如测试复杂性、测试费用、测试时间等、在测试性指标输入及测试性模型的基础上选出候选测试
8、在用户指定的层级和范围上，基于测试性模型，对候选测试集的测试性指标（故障检测率、故障隔离率）进行预计
9、在用户指定的层级和范围上，基于测试性模型，在候选测试集的基础上生成故障诊断决策树
可以使用一个简单但能说明问题的案例跑通全部流程（可以构造一个演示用的项目文件及其他相关文件，如果你不好直接生成相关文件，则请撰写mardown文档，一步步教我在软件中构建这个演示项目，每一步都要非常详细，在写这份详细的文档时，也请你对照着再检查一遍代码，看功能是否都已实现，业务和交互逻辑是否存在错误或疏漏）。
以上开发需求，下面是决策要求：
我先睡觉了，所有产品和技术决策由你来掌控，明早我来验收成果
﹣大概睡8小时，所以不要急着出结果，所有细节你慢慢做，不要节约token，做对最重要
﹣遇到不确定的功能需求，可以先仔细分析各种可能，并按最科学合理的来
- 在具体代码上，如果遇到不确定的，先查一下MCP context7里的文档，还不确定地，网上搜索一下
﹣需要花大量的时间用于任务分解，这部分不要怕浪费时间，正所谓磨刀不误砍柴工，分解后的子任务在做完后需要进行检查，以免全搞完了发现不行要推倒重来
﹣你搞定功能就行,界面部分不要纠结，有基本的就可以，尽量用Qt桌面软件中的主流通俗写法（我的Qt版本为5.12），明天我来打磨细节



  下一步（阶段 3）建议

  - 在 DiagnosticMatrixBuilder 基础上实现 D 矩阵持久化与 UI 展示，接入容器层级过滤。
  - 设计检测率/隔离率的层级分解算法，并允许在测试管理界面查看与调整。
  - 开始接入多维度约束筛选及诊断决策树生成骨架，为后续指标预估与候选测试优化铺路。


一、系统核心功能
实现复杂系统的分层模型；层次包括：系统、子系统、LRU、SRU、模块、子模块、元件；现有软件中插入到图纸中的每一个"元件"默认对应为元件级，然后系统可以再建立不同层次的容器，现有软件中的实体"元件"不能同时出现在多个同一层次的容器中，某一个低层级的容器也不能同时出现在多个同一层次的高层级容器中，用户可通过软件界面方便地进行层次化的建模。各层级容器的数据模型可以借鉴树状图。每个容器都有：接口定义，功能行为描述，其中功能行为描述中包括一个正常状态模式与多个故障模式以及一个未知故障(未知故障相当于不对元件功能行为做任何约束，所以不用显式建模)，每个实体“元件”只能处于一种状态。
比如一个实体“元件”继电器K1，被插入到系统中，默认会自动为其生成一个同名元件层的容器，这个元件层由于有且只有K1，所以这个元件层容器可以直接根据继电器K1现有的接口描述（功能子块）、功能行为描述（元件T语言）来生成自己的接口描述与功能行为描述。如果这个系统只有一个实体“元件”，则在元件层上面可以再建立一个系统层（元件层容器可以直接被系统层容器包含，中间的层级可以没有，但被包含的容器的层级一定比当前容器的层级低），系统层在逻辑层面的描述（接口与功能行为）直接就与元件层的一致；现增加一个实体“元件”电磁铁YV1，默认会自动为其生成一个同名元件层的容器，YV1和K1共同构成了一个子系统，则可以在系统层下面增加一个子系统层，包含K1和YV1的元件层容器。此时子系统层的容器的接口与功能行为描述就需要根据两个元件容器的描述来自动生成，这里需要设计一个算法，可以用一个整合后的描述（接口、功能行为）去等效替代各子容器的一个综合效果。被包含子容器的之间相互连接的接口（如果都是内部容器间的接口相连，不涉及高层级容器之外的容器）则在高层级容器里就变成了内部接口，也就是自身功能行为的一部分，对外就不用体现这个内部接口。高层级容器的故障模式也是根据低层级的故障模式总结而来，用户可设定容器的故障模式分析层级，默认是本层级，同时用户也可将其设为比当前容器层级更低的层级，设到哪一级，就分析到哪一级（也就是以当前容器中设定的低层级容器直接参与分析计算，而不是直接使用整合好的高层级容器）。如果一个较高层级容器只包含一个低层级的容器，则直接原封不动地继承其所有特性，如果包含二个或多个低层级的容器，则自身的状态就整合为正常、故障两种，多个容器整合后就没有未知模式了（即此时就只有正常模式，以及正常模式的反面），因为整合后容器就只描述正常的功能行为，非正常的即为故障。具体的整合方法（等价化简与消元）需要仔细考虑与设计。
这么做的目的一是方便在不同的层级对系统进行分析，二是在分析大规模系统时软件会有更好的性能表现。这里需要考虑的另一个核心问题即容器的接口应如何定义、描述，容器自身的功能、行为应如何描述。我们在这里可以重新对此进行设计，以方便我们实现更高级别的软件功能，对于原有系统中的实体“元件”只需要进行一次转换即可。
如果把多个模块进行整合在一起，能否使用z3定理证明器得到这些模块整合在一起的等效功能、行为描述？（相当于每个模块有语句或公式对其进行描述，将多个模块的语句/公式合在一起后，能否使用z3定理证明器进行符号运算，对整合的结果化简）请结合代码分析来给出建议。模块描述现在用的是smt语法，请分析为了实现上述功能的具体代码实现细节。

现有的实体“元件”的smt描述例子：
"电流流出器件为负，流入器件为正"
"电机""MD"
"Resistance=22"
"OutputF=-1200"
"ActCurrent=0.8"
"RatedVoltage=220"

"变量定义"
(declare-fun %MD%.M1.act () Bool)
(declare-fun %MD%.M1.F () Real)
(declare-fun %MD%.M1.M () Real)
(declare-fun %MD%.A_B.u () Real)
(declare-fun %MD%.A_B.i () Real)
(declare-fun %MD%.A_B.R () Real)

"正常模式"
(assert (= %MD%.A_B.R %Resistance%))
(assert (= (* %MD%.A_B.i %MD%.A_B.R) %MD%.A_B.u))
(assert (ite (and (>= %MD%.A_B.u (* %RatedVoltage% 0.8)) (<= %MD%.A_B.u (* %RatedVoltage% 1.2))) (= %MD%.M1.act true) (= %MD%.M1.act false)))
(assert (ite (= %MD%.M1.act true) (and (> %MD%.M1.M 0) (> %MD%.M1.F 0)) (= %MD%.M1.M 0)))

"故障模式"
<unknownfault>

<p>5.0e-7</p>
</unknownfault>
<common>
(assert (= (* %MD%.A_B.i %MD%.A_B.R) %MD%.A_B.u))
(assert (= %MD%.M1.act false))
(assert (= %MD%.M1.M 0))
</common>
<fault>
<name>绕组开路</name>
<p>2.0e-6</p>
<describe>
(assert (> %MD%.A_B.R 100000000))
</describe>
</fault>
<fault>
<name>转轴卡滞</name>
<p>1.0e-5</p>
<describe>
(assert (= %MD%.A_B.R %Resistance%))
</describe>
</fault>

二、用户工作流程：
1、根据实际系统的硬件组成在工程文件中增加各实体“元件”
2、给系统定义功能，按“所需的输入+期望的输出”模式定义功能，（特定器件的特定输出或特定输出范围即可定义为一个功能），功能与功能之间可以存在依赖关系，如果B功能依赖A功能，则B功能在定义输入时，可以不显式定义A功能所需的输入（系统可以动态计算得到实际所需的输入）。系统的故障即定义为功能失常（输入符合要求但实际输出与期望的输出不符）。
3、在实际硬件组成的基础上建立分层模型
4、在元件层的最详细的模型中，让软件自动创建所有可用的测试，这里也需要仔细思考，如何给出，共有3类测试：
1）信号类测试：根据模型中各接口处的信号类型直接给出，比如系统中共有10个接口，5个电气接口（电压、电流），4个液压接口（油压、流量），1个机械接口（速度、位移），则共有20个可用接口。每类接口的可用测试可以统一定义，针对特定接口还可以手动修改。如何确定某处信号类测试是否能测到某一个故障，需要仔细设计一个高效的算法来实现。
2）功能类测试：属于虚测试（就是理论上存在的测试，不考虑具体的测试实现方式），此类测试可以直接测出功能是否正常，默认针对每个功能创建一个功能类测试；
3）故障模式测试：属于虚测试，此类测试可以直接测试某元件是否处于特定的故障模式，又可细分为：正常判别测试（即可测出模块是否正常），特定故障模式测试（即可测试元件是否处于某一特定的故障模式），默认对每个元件创建一个正常判别测试。如何确定某个元件的正常判别测试是否能测到某一个故障：假设该元件正常判别测试不通过，同时设故障对应的功能正常，各变量的取值都在合理范围内（防止SMT求解器找到在数学上满足但在实际中根本不可能取到的值），看约束满足性问题是否解为可满足。
4）自动创建所有可用测试后，用户可对创建的可用测试进行增、删、改、查等操作
5、根据系统模型建立测试性模型（依赖矩阵，又称为D矩阵，是一种经典的测试性模型）
6、用户对在指定的系统层级输入要求的测试性指标（故障检测率、故障隔离率），软件可以按要求对高层级上的指标分解到其所属的各低层级的容器上
7、在用户指定的层级和范围上，用户指定多维度的约束，例如测试复杂性、测试费用、测试时间等、在测试性指标输入及测试性模型的基础上选出候选测试
8、在用户指定的层级和范围上，基于测试性模型，对候选测试集的测试性指标（故障检测率、故障隔离率）进行预计
9、在用户指定的层级和范围上，基于测试性模型，在候选测试集的基础上生成故障诊断决策树
以上是用户的工作流程，现在需要在软件中实现该工作流程，有些模块、功能可能已经实现了，但你也要再捋一遍，确保各模块的功能都是正确的，各模块之间的功能和接口都是匹配的，整体上是可以无缝衔接，同时要查漏补缺，看哪些功能或者关键算法还未实现，需要全面地实现所有的需求与功能，在软件中实现并演示最基本的工作流程（现项目中已设计了一个demo_projectbuilder，用来构造一个演示用的项目文件及其他相关文件，该功能使用一个简单但能说明问题的案例跑通全部流程，这个案例还可以再丰富一些，细节上也再深入一些，在实现这个构造演示项目的功能时，也请你对照着再检查一遍代码，看功能是否都已实现，业务和交互逻辑是否存在错误或疏漏）。 
以上开发需求，下面是决策要求：
  我先睡觉了，所有产品和技术决策由你来掌控，明早我来验收成果
  - 大概睡8小时，所以不要急着出结果，所有细节你慢慢做，不要节约token，做对最重要
  - 遇到不确定的功能需求，可以先仔细分析各种可能，并按最科学合理的来
  - 在具体代码上，如果遇到不确定的，先查一下MCP context7里的文档，还不确定地，网上搜索一下
  - 需要花大量的时间用于任务分解，这部分不要怕浪费时间，正所谓磨刀不误砍柴工，分解后的子任务在做完后需要进行检查，以免全搞完了发现不行要推倒重来
  - 你搞定功能就行,界面部分不要纠结，有基本的就可以，尽量用Qt桌面软件中的主流通俗写法（我的Qt版本为5.12），明天我来打磨细节