1）请将Container Tree界面的入口挂到工具栏（在“设计”栏目中已有一个“层次模型”的按钮，关联上即可）；
2）且在界面上不光是提供一个入口，而且要与现有的界面进行集成：在mainwindow.ui的treeViewUnits实体元件列表中，每个实体元件的右键菜单为：新建子块、新建子块(模板)、元件属性、删除、复制元件、整体放置、新建元件、粘贴子块；需要在上述右键菜单中增加一组动作，为了视觉上的清晰，可以分隔线隔出来：1、（"为实体元件添加元件层容器"，对于多选的一组实体元件可批量添加）；2、（“删除元件层容器”，对于多选的一组实体元件可批量删除，且自动跳过没有元件容器的实体元件）；3、（“将实体元件层添加到高层级容器”，对于多选的一组实体元件可批量添加，且自动跳过没有元件层容器的实体元件，高层级容积可以是已有的，也可以用户新建）；4、（“层级：无/所属层级及层级名”，如果同时属于多个层级，则显示最高的那个层级，如果已有所属的层级，则还有下一级菜单，分别列出所有包含此实体元件的所有层级及层级名，如"元件：HL1"、"LRU：LRU-HL1"、"子系统：Subsystem-HL1,HL2,KA1"，然后对于每一个非元件层的项又有下一级菜单：“添加低层级容器”、“从中删除容器”、“将当前层级添加到高层级容器”、“重命名当前容器”，用户为容器取的名字放在容器名称的最前面，且用-隔开，如"照明-Subsystem-HL1,HL2,KA1"，后面的"Subsystem-HL1,HL2,KA1"用户不可修改，由系统自动维护，在容器包含的元件层发生变化时自动更新，但为了可读性，最多显示10个用逗号分隔，多于10个的显示前10个+"...等共x项"）。上述菜单项如果涉及更进一步的操作，可根据需要弹出对话框让用户进一步处理。
3）需要仔细检查、实现以下逻辑与规则：


1）之前你的设计“为多选的“元件”批量创建元件层容器（默认名取 Equipment.Name，若空则取 DT）”，需修改为：
默认名取Equipment.DT，同时在元件层容器中记录Equipment_ID、Equipment.Type和Equipment.Name，以备在不同场合下按需进行显示。
2）现在containertreedialog.cpp中labelsFor与acceptSelection可以正确编译，在软件中也可以正确显示中文字符，但软件可读性很差，请在源码中直接使用中文。为避免编译与可能的其他问题，请参考我mainwindow.cpp中已有右键菜单中的中文项的写法，之前的也是径测试正常的，与其保持一致即可。

待修改内容：
一）treeViewUnits里：
1）实体元件的右键菜单中"从中删除容器"为从当前容器中删除本实体元件对应的元件容器，并不是删除此高级别的容器及其子容器；现在做成了和containertreedialog中的删除逻辑一样，应该要不一样才对。"从中删除容器"的名称也改为"从中删除本元件容器"
2）实体元件的右键菜单中"添加低层级容器"，不要让用户手输，而是应该让用户在containertreedialog中的Component类型的容器中去选择；
二）containertreedialog里
1）容器的默认排序为按其顶层容器的级别从低级到高级别排序，且点击Type表头后可在从低到高与从高低之间切换
2）treeView中的多列宽度布局需要修改，现在是Type较宽，会随窗口宽度的变化而变化，但Type显示的内容比较固定，真正需要较宽空间来显示的是Name列，而不是Type列。
3）需要treeView开启ExtendedSelection，同时将右键菜单中的那套逻辑在containertreedialog中也进行实现（添加低层级容器、将当前层级添加到高层级容器）。由于在右键菜单和containertreedialog中的逻辑是一致的，看能否在统一的一处地方实现并复用这部分逻辑与代码，以方便维护。


void MainWindow::DeleteDwgTerminalByPageAndHandle(QString Page_ID,QString Handle)
{
    QString dwgfilename=GetPageNameByPageID(Page_ID.toInt());
    QString dwgfilepath=CurProjectPath+"/"+dwgfilename+".dwg";
    qDebug()<<"DeleteDwgSymbolByPageAndHandle,dwgfilepath="<<dwgfilepath<<"Handle="<<Handle;
    QFile dwgfile(dwgfilepath);
    if(!dwgfile.exists()) return;
    //查看page是否已打开
    //查看是否已经打开改图纸
    for(int i=0;i<ui->mdiArea->subWindowList().count();i++)
    {
        //if(ui->mdiArea->subWindowList().at(i)->windowTitle().contains("故障诊断")) continue;
        if(ui->mdiArea->subWindowList().at(i)->windowTitle()==dwgfilename)
        {
            ((formaxwidget *)ui->mdiArea->subWindowList().at(i)->widget())->DeleteEnty(Handle);
            return;
        }
    }
    bool Ret=GlobalBackAxWidget->dynamicCall("OpenDwgFile(QString)",dwgfilepath).toBool();
    qDebug()<<"DeleteDwgSymbolByPageAndHandle,OpenDwgFile "<<Ret;
    IMxDrawEntity *EntyDelete=(IMxDrawEntity *)GlobalBackAxWidget->querySubObject("HandleToObject(const QString)",Handle);
    if(EntyDelete!=nullptr) EntyDelete->dynamicCall("Erase()");
    GlobalBackAxWidget->dynamicCall("SaveDwgFile(QString)",dwgfilepath);
}
之前版本的代码是上面这样的，为什么需要修改成这样？
    GlobalBackAxWidget->dynamicCall("OpenDwgFile(QString)",dwgfilepath);
    qDebug()<<"DeleteDwgSymbolByPageAndHandle,OpenDwgFile "<<Ret;
    IMxDrawEntity *EntyDelete=(IMxDrawEntity *)GlobalBackAxWidget->querySubObject("HandleToObject(const QString)",Handle);
    if(EntyDelete!=nullptr) EntyDelete->dynamicCall("Erase()");
    GlobalBackAxWidget->dynamicCall("SaveDwgFile(QString)",dwgfilepath);
